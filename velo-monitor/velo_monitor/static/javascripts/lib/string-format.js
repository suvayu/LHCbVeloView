// Generated by CoffeeScript 1.6.3
(function() {
  var KeyError, ValueError, consume_expression, consume_literal, descend, evaluate, exponent, format, format_number, format_string, format_value, get, pad, tokenize, tokenize_format_spec,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  exponent = function(n, e) {
    if (e == null) {
      e = 0;
    }
    switch (false) {
      case !((-1 < n && n < 1)):
        return exponent(n * 10, e - 1);
      case !((-10 < n && n < 10)):
        return e;
      default:
        return exponent(n / 10, e + 1);
    }
  };

  pad = function(string, fill, align, width) {
    var idx, padding;
    padding = Array(Math.max(0, width - string.length + 1)).join(fill);
    switch (align) {
      case '<':
        return string + padding;
      case '>':
        return padding + string;
      case '^':
        idx = Math.floor(padding.length / 2);
        return padding.substr(0, idx) + string + padding.substr(idx);
    }
  };

  KeyError = (function(_super) {
    __extends(KeyError, _super);

    function KeyError(message) {
      this.message = message;
    }

    KeyError.prototype.name = 'KeyError';

    return KeyError;

  })(Error);

  ValueError = (function(_super) {
    __extends(ValueError, _super);

    function ValueError(message) {
      this.message = message;
    }

    ValueError.prototype.name = 'ValueError';

    return ValueError;

  })(Error);

  consume_literal = function(str, memo) {
    var _ref;
    if (memo == null) {
      memo = '';
    }
    if (str.length === 0) {
      return [memo, str];
    } else if (((_ref = str[0]) === '{' || _ref === '}') && str[0] === str[1]) {
      return consume_literal(str.substr(2), memo + str[0]);
    } else if (str[0] === '{') {
      return [memo, str];
    } else if (str[0] === '}') {
      throw new SyntaxError('unmatched, unescaped "}" in format string');
    } else {
      return consume_literal(str.substr(1), memo + str[0]);
    }
  };

  consume_expression = function(str, memo, depth) {
    var m, _ref, _ref1;
    if (memo == null) {
      memo = '';
    }
    if (depth == null) {
      depth = 0;
    }
    if (depth > 1) {
      throw new ValueError('max string recursion exceeded');
    } else if (str.length === 0 || str[0] === '}' && depth === 0) {
      m = /^([^!:]*)(?:!([^:]*))?(?::(.*))?$/.exec(memo);
      if (m[2] === '') {
        throw new ValueError('invalid transformer name');
      }
      return [
        {
          field_name: m[1],
          transformer: (_ref = m[2]) != null ? _ref : '',
          format_spec: (_ref1 = m[3]) != null ? _ref1 : ''
        }, str
      ];
    } else {
      return consume_expression(str.substr(1), memo + str[0], (function() {
        switch (str[0]) {
          case '{':
            return depth + 1;
          case '}':
            return depth - 1;
          default:
            return depth;
        }
      })());
    }
  };

  tokenize = function(chars, memo, type) {
    var remainder, token, _ref, _ref1;
    if (memo == null) {
      memo = [];
    }
    if (type == null) {
      type = 'literal';
    }
    if (chars.length === 0) {
      return memo;
    } else if (type === 'literal') {
      _ref = consume_literal(chars), token = _ref[0], remainder = _ref[1];
      return tokenize(remainder, __slice.call(memo).concat([token]), 'expression');
    } else if (type === 'expression') {
      _ref1 = consume_expression(chars.substr(1)), token = _ref1[0], remainder = _ref1[1];
      if (remainder) {
        return tokenize(remainder.substr(1), __slice.call(memo).concat([token]), 'literal');
      } else {
        throw new SyntaxError('unmatched, unescaped "{" in format string');
      }
    }
  };

  tokenize_format_spec = function(format_spec) {
    var chars, key, keys, processor, processors, tokens, _i, _j, _len, _len1;
    chars = format_spec.split('');
    keys = 'fill align sign # 0 width , precision type'.split(' ');
    tokens = {};
    for (_i = 0, _len = keys.length; _i < _len; _i++) {
      key = keys[_i];
      tokens[key] = '';
    }
    processors = [
      function() {
        var _ref, _ref1;
        if ((_ref = chars[1]) === '<' || _ref === '>' || _ref === '=' || _ref === '^') {
          tokens['fill'] = chars.shift();
        }
        if ((_ref1 = chars[0]) === '<' || _ref1 === '>' || _ref1 === '=' || _ref1 === '^') {
          return tokens['align'] = chars.shift();
        }
      }, function() {
        var _ref;
        if ((_ref = chars[0]) === '+' || _ref === '-' || _ref === ' ') {
          return tokens['sign'] = chars.shift();
        }
      }, function() {
        if (chars[0] === '#') {
          return tokens['#'] = chars.shift();
        }
      }, function() {
        if (chars[0] === '0') {
          return tokens['0'] = chars.shift();
        }
      }, function() {
        var _results;
        _results = [];
        while (/\d/.test(chars[0])) {
          _results.push(tokens['width'] += chars.shift());
        }
        return _results;
      }, function() {
        if (chars[0] === ',') {
          return tokens[','] = chars.shift();
        }
      }, function() {
        if (chars[0] === '.') {
          chars.shift();
          while (/\d/.test(chars[0])) {
            tokens['precision'] += chars.shift();
          }
          if (!tokens['precision']) {
            throw new SyntaxError('format specifier missing precision');
          }
        }
      }, function() {
        return tokens['type'] = chars.shift();
      }
    ];
    for (_j = 0, _len1 = processors.length; _j < _len1; _j++) {
      processor = processors[_j];
      if (chars.length) {
        processor();
      }
    }
    if (chars.length) {
      throw new SyntaxError('unused characters in format specifier');
    }
    tokens.toString = function() {
      return ((function() {
        var _k, _len2, _results;
        _results = [];
        for (_k = 0, _len2 = keys.length; _k < _len2; _k++) {
          key = keys[_k];
          _results.push(this[key]);
        }
        return _results;
      }).call(this)).join('');
    };
    return tokens;
  };

  format_value = function(value, tokens) {
    switch (Object(value).constructor) {
      case Number:
        return format_number(value, tokens);
      case String:
        return format_string(value, tokens);
      default:
        if (String(tokens)) {
          throw new ValueError('non-empty format string for {0.2} object'.format(Object.prototype.toString.call(value).split(/\W/)));
        }
        return String(value);
    }
  };

  format_string = function(value, tokens) {
    var align, fill, precision, template, _ref;
    fill = tokens['fill'] || tokens['0'] || ' ';
    align = tokens['align'] || (tokens['0'] ? '=' : '<');
    precision = Number(tokens['precision'] || value.length);
    if ((_ref = tokens['type']) !== '' && _ref !== 's') {
      template = 'unknown format code "{type}" for String object';
      throw new ValueError(template.format(tokens));
    }
    if (tokens[',']) {
      throw new ValueError('cannot specify "," with "s"');
    }
    if (tokens['sign']) {
      throw new ValueError('sign not allowed in string format specifier');
    }
    if (tokens['#']) {
      throw new ValueError('alternate form (#) not allowed in string format specifier');
    }
    if (align === '=') {
      throw new ValueError('"=" alignment not allowed in string format specifier');
    }
    return pad(value.substr(0, precision), fill, align, Number(tokens['width']));
  };

  format_number = function(value, tokens) {
    var align, chars, chr, factor, fill, fract, idx, min, n, p, precision, prefix, s, sign, template, type, unshift, whole, width, _i, _ref, _ref1;
    fill = tokens['fill'] || tokens['0'] || ' ';
    align = tokens['align'] || (tokens['0'] ? '=' : '>');
    width = tokens['width'];
    type = tokens['type'];
    switch (type) {
      case 'c':
      case 'd':
      case 'b':
      case 'o':
      case 'x':
      case 'X':
        if (value % 1 < 0 || value % 1 > 0) {
          template = 'cannot format non-integer with format specifier "{}"';
          throw new ValueError(template.format(type));
        }
        if (tokens[','] && type !== 'd') {
          throw new ValueError('cannot specify "," with "{}"'.format(type));
        }
        if (tokens['precision']) {
          throw new ValueError('precision not allowed in integer format specifier');
        }
        break;
      case 'e':
      case 'E':
      case 'f':
      case 'g':
      case 'G':
      case '%':
        precision = Number(tokens['precision'] || '6');
        break;
      case '':
        break;
      default:
        template = 'unknown format code "{}" for Number object';
        throw new ValueError(template.format(type));
    }
    switch (type) {
      case 'c':
        if (tokens['sign']) {
          throw new ValueError('sign not allowed with format specifier "c"');
        }
        s = String.fromCharCode(value);
        break;
      case 'd':
        s = Math.abs(value).toString(10);
        break;
      case 'b':
        s = Math.abs(value).toString(2);
        break;
      case 'o':
        s = Math.abs(value).toString(8);
        break;
      case 'x':
      case 'X':
        s = Math.abs(value).toString(16);
        if (type === 'X') {
          s = s.toUpperCase();
        }
        break;
      case 'e':
      case 'E':
        s = Math.abs(value).toExponential(precision);
        if (tokens['#']) {
          s = s.replace(/[.]|(?=e)/, '.');
        }
        if (type === 'E') {
          s = s.toUpperCase();
        }
        break;
      case 'f':
        s = Math.abs(value).toFixed(precision) + (tokens['#'] && precision === 0 ? '.' : '');
        break;
      case 'g':
      case 'G':
        p = precision || 1;
        if ((-4 <= (_ref = exponent(value)) && _ref < p)) {
          factor = Math.pow(10, p - 1 - exponent(Math.abs(value)));
          n = Math.round(Math.abs(value) * factor) / factor;
          s = String(n);
          if (tokens['#']) {
            if (n % 1 === 0) {
              s += '.';
            }
            s += Array(p - s.match(/\d/g).length + 1).join('0');
          }
        } else {
          s = Math.abs(value).toExponential(Math.max(0, p - 1));
          s = tokens['#'] ? s.replace(/[.]|(?=e)/, '.') : s.replace(/[.]?0+(?=e)/, '');
        }
        if (type === 'G') {
          s = s.toUpperCase();
        }
        break;
      case '%':
        s = Math.abs(value * 100).toFixed(precision) + '%';
        break;
      case '':
        if (tokens['precision']) {
          tokens['type'] = 'g';
          return format_number(value, tokens);
        } else {
          s = Math.abs(value).toString(10);
        }
    }
    sign = value < 0 || 1 / value < 0 ? '-' : tokens['sign'] === '-' ? '' : tokens['sign'];
    prefix = __indexOf.call('boxX', type) >= 0 && tokens['#'] && '0' + type || '';
    if (tokens[',']) {
      _ref1 = (idx = s.indexOf('.')) >= 0 ? [s.substr(0, idx), s.substr(idx)] : [s, ''], whole = _ref1[0], fract = _ref1[1];
      chars = [];
      unshift = function(chr) {
        if (chars.length === 3 || chars[3] === ',') {
          chars.unshift(',');
        }
        return chars.unshift(chr);
      };
      for (_i = whole.length - 1; _i >= 0; _i += -1) {
        chr = whole[_i];
        unshift(chr);
      }
      if (align !== '=') {
        return pad(sign + chars.join('') + fract, fill, align, width);
      } else if (fill === '0') {
        min = width - sign.length - fract.length;
        while (!(chars.length >= min)) {
          unshift(fill);
        }
        return sign + chars.join('') + fract;
      } else {
        return sign + pad(chars.join('') + fract, fill, '>', width - sign.length);
      }
    } else if (align === '=') {
      return sign + prefix + pad(s, fill, '>', width - sign.length - prefix.length);
    } else {
      return pad(sign + prefix + s, fill, align, width);
    }
  };

  get = function(x, prop) {
    if (!(prop in Object(x))) {
      throw new KeyError('"{}"'.format(prop.replace(/"/g, '\\"')));
    }
    if (typeof x[prop] === 'function') {
      return x[prop]();
    } else {
      return x[prop];
    }
  };

  descend = function(x, path) {
    if (path.length === 0) {
      return x;
    } else {
      return descend(get(x, path[0]), path.slice(1));
    }
  };

  evaluate = function(expr, ctx) {
    var val;
    val = descend(ctx, expr.field_name.split('.'));
    if (expr.transformer === '') {
      return val;
    } else if (Object.prototype.hasOwnProperty.call(format.transformers, expr.transformer)) {
      return format.transformers[expr.transformer](val);
    } else {
      throw new ValueError('unknown transformer "{}"'.format(expr.transformer.replace(/"/g, '\\"')));
    }
  };

  format = function() {
    var args, normalize, template, token, values;
    template = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    normalize = (function(idx, modes) {
      return function(field_name) {
        if (field_name) {
          if ((modes[modes.length] = 'explicit') !== modes[0]) {
            throw new ValueError('cannot switch from implicit to explicit numbering');
          }
          if (/^\d+(?:[.]|$)/.test(field_name)) {
            return field_name;
          } else {
            return "0." + field_name;
          }
        } else {
          if ((modes[modes.length] = 'implicit') !== modes[0]) {
            throw new ValueError('cannot switch from explicit to implicit numbering');
          }
          return "" + (idx++);
        }
      };
    })(0, []);
    values = (function() {
      var _i, _len, _ref, _results;
      _ref = tokenize(template);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        token = _ref[_i];
        switch (Object.prototype.toString.call(token)) {
          case '[object String]':
            _results.push(token);
            break;
          case '[object Object]':
            token.field_name = normalize(token.field_name);
            _results.push(format_value(evaluate(token, args), tokenize_format_spec(token.format_spec.replace(/\{(.*?)\}/g, function(match, field_name) {
              return descend(args, normalize(field_name).split('.'));
            }))));
            break;
          default:
            _results.push(void 0);
        }
      }
      return _results;
    })();
    return values.join('');
  };

  String.prototype.format = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return format.apply(null, [this].concat(__slice.call(args)));
  };

  String.prototype.format.transformers = format.transformers = {};

  String.prototype.format.version = format.version = '0.2.1';

  if (typeof module !== "undefined" && module !== null) {
    module.exports = format;
  }

}).call(this);
